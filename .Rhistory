use_testthat()
use_test()
styler:::style_active_file()
gp_prior
set.seed(100)
xc <- seq(0, 1, length.out = 100)
xt <- seq(1, 2, length.out = 100)
yc <- 1 * xc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(100, 0, 0.25)
length(xc)
length(gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)$mean_control
)
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 2, l = 1, alpha = 0 )
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 2, l = 0, alpha = 1)
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 2, l = 0, alpha = 1)
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 0)
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 0, alpha = 0 )
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 2, l = 0, alpha = 0 )
gp_posterior
set.seed(100)
xc <- seq(0, 1, length.out = 5)
xt <- seq(1, 2, length.out = 5)
yc <- 1 * xc + rnorm(5, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(5, 0, 0.25)
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)
length(gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)
)
length(gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)$post_mean_c)
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)$post_mean_c
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)$posterior_c_mean
class(gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1))
class(gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 3, l = 1))
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 3, l = 1))
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 3, l = 1)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
class(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))
class(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)[1])
(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)[1])
(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)[1])
(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 1, sigma_hat = 1.2, choice = 1, l = 0.7)[1])
usethis::use_github_action("test-coverage")
usethis::use_coverage()
usethis::use_github_action("test-coverage")
library(GPRdd)
class(gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1))$cov_c
class(gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 1)$cov_c)
gp_prior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 0)
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = 0)
gp_posterior(Xc = xc, Xt = xt, Yc = yc, Yt = yt, sigma_hat = 1, choice = 1, l = -1)
library(GPRdd)
set.seed(100)
xc <- seq(0, 1, length.out = 5)
xt <- seq(1, 2, length.out = 5)
yc <- 1 * xc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(100, 0, 0.25)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
set.seed(100)
xc <- seq(0, 1, length.out = 100)
xt <- seq(1, 2, length.out = 100)
yc <- 1 * xc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(100, 0, 0.25)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 3, l = 1)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 2, l = 1, alpha = 0)
library(GPRdd)
8!
8*7*6*5_5
8*7*6*5*6
table <- matrix(c(12,16,17,15,13,20,17,10), nrow=1)
table
chisq.test(table)
pchisq(.1,7)
?pchisq
pchisq(.9,7)
pchisq(.95,7)
library(GPRdd)
?create_plot
library(GPRdd)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
library(GPRdd)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
set.seed(100)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
class(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))[1]
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
class(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))[2]
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))[1]
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
rs = create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
rs = create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
rs
class(rs)
class(rs)[1]
class(rs)[2]
library(GPRdd)
sc <- seq(0, 1, length.out = 100)
st <- seq(1, 2, length.out = 100)
yc <- 1 * sc + rnorm(100, 0, 0.25)
yt <- 2 + 1 * st + rnorm(100, 0, 0.25)
x <- c(sc, st)
x <- as.matrix(x)
y <- c(yc, yt)
rs = create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
rs
class(rs)[1]
class(rs)[2]
class(rs)[[1]]
set.seed(100)
sc = seq(0, 1, length.out = 50)
st = seq(1, 2, length.out = 50)
yc = 1 * sc + rnorm(50, 0, 0.25)
yt = 2 + 1*st + rnorm(50, 0, 0.25)
x = c(sc, st)
x = as.matrix(x)
y = c(yc, yt)
gp_prior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7 )
set.seed(100)
sc = seq(0, 1, length.out = 50)
st = seq(1, 2, length.out = 50)
yc = 1 * sc + rnorm(50, 0, 0.25)
yt = 2 + 1*st + rnorm(50, 0, 0.25)
x = c(sc, st)
x = as.matrix(x)
y = c(yc, yt)
head(gp_prior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7))
head(gp_posterior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7))
create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
length(create_plot(X = x, Y = y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7))[1]
devtools::install_github("ejgao/GPRrdd", build_vignettes = TRUE)
library(GPRdd)
?create_plot
runif(1)==runif(1)
set.seed(123)
runif(1)==runif(1)
set.seed(123)
runif(1)
set.seed(123)
runif(1)
set.seed(100)
set.seed(100)
xc <- seq(0, 1, length.out = 5)
xt <- seq(1, 2, length.out = 5)
yc <- 1 * xc + rnorm(5, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(5, 0, 0.25)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
x
t
y
xc
xt
set.seed(100)
xc <- seq(0, 1, length.out = 5)
xt <- seq(1, 2, length.out = 5)
yc <- 1 * xc + rnorm(5, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(5, 0, 0.25)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
y
set.seed(100)
xc <- seq(0, 1, length.out = 5)
xt <- seq(1, 2, length.out = 5)
yc <- 1 * xc + rnorm(5, 0, 0.25)
yt <- 2 + 1 * xt + rnorm(5, 0, 0.25)
x <- as.matrix(c(xc, xt))
y <- c(yc, yt)
y
1- pchisq(0.10, 7)
1- qchisq(0.10, 7)
1- qchisq(0.90, 7)
1-pchisq(0.90, 7)
1-pchisq(4.8, 7)
library(GPRdd)
?create_plot
?lm
devtools::install_github("bitansa/ReciprocalGraphicalModels")
library("ReciprocalGraphicalModels")
help(RGM)
?lm
?create_plot
library(GPRdd)
?create_plot
?lm
help(RGM)
?lm
library(GPRdd)
?gp_posterior
?create_plot
?gp_prior
library(GPRdd)
?create_plot
?gp_prior
?gp_posterior
library(GPRdd)
?gp_prior
?gp_posterior
?create_plot
devtools::install_github("ejgao/GPRrdd", build_vignettes = TRUE)
library(GPRdd)
?create_plot
vignette(create_plot)
vignette(GPRdd)
vignette(package = "GPRdd")
v1 = vignette(package = "GPRdd")
view(v1)
print(v1)
gp_op
gp_posterior
devtools::install_github("https://github.com/androsrj/pshd")
library(pshd)
?estimate_pshd
?create_plot
library(GPRdd)
library(GPRdd)
https://github.com/ejgao/GPRrdd.git
devtools::install_github("ejgao/GPRrdd")
library(GPRdd)
devtools::install_github("ejgao/GPRrdd", build_vignettes = TRUE)
library(GPRdd)
?create_plot
devtools::install_github("niladrik/GPHS", build_vignettes = TRUE)
vignette("GPHS)
vignette("GPHS")
library(GPHS)
vignette("GPHS")
vignette(GPHS\)
vignette(GPHS)
vignette(package = "GPHS")
vignette(my-vignette)
vignette(my_vignette)
vignette("my-vignette")
vignette("my-vignette")
library(ggplot2)
# setting the seed for reproducibility of the data
set.seed(12345)
f_data <- function(x){
func <- 0
for(j in 1:5000){
func <- func + jˆ(-1.7) * sin(j) * cos(pi * (j - 0.5) * x)
}
return(func)
}
x = seq(1, 1e-3, -0.01)
# true value (latent variable)
ff = f_data(x)
?mySolve
?inv_and_logdet
?dmvnorm_own
?SurrogateMH
?SurrogateSS
?SurrogateMH
?ESS
?mySolve
?mySolve
?dmvnorm_own
?inv_and_logdet
pf(1/6, 2, 12)
pf(6/11, 2, 12)
pf(1/11, 2, 12)
library(GPRdd)
library(GPRdd)
devtools::spell_check()
devtools::spell_check()
library(GPRdd)
devtools::install_github("ejgao/GPRrdd", build_vignettes = TRUE)
library(GPRdd)
?create_plot
vignette(package = "GPRdd")
vignette("my-vignette")
vignette("my-vignette", package = "GPRdd")
devtools::install_github("sakulcodes/MFMSBM")
library(MFMSBM)
devtools::install_github("sakulcodes/MFMSBM")
library(MFMSBM)
## generate the data
set.seed(33)
n = 100 ## number of observations
kk = 3 ## number of clusters
Z <- c(sample(1:kk, size = kk, replace = FALSE),
sample(1:kk, size = n-kk, replace = TRUE,prob = c(1,1,1))) # clustering configuration
Z = Z[order(Z)]
theta <- matrix(0.1,kk,kk) ## off-diagonal value for Q matrix
diag(theta) = 0.6 ## diagonal value for Q matrix
A = matrix(0,n,n) ##the adjacency matrix
AAA = matrix(0,n,n) ##the upper traiangle for the adjacency matrix
for (i in 1:n){
for (j in i:n){
A[i,j] = rbinom(1,1,prob=theta[Z[i],Z[j]])
A[j,i] = A[i,j]
AAA[i,j] = A[i,j]
}
}
diag(AAA) = 0 ## making it without-selfloop network
diag(A) = 0 ## making it without-selfloop networkk
## taking the data into the MFM-SBM algorithm
set.seed(1)
fit1 = CDMFM_new(data = A, data1 = AAA, niterations = 100, beta.a = 1, beta.b = 1, GAMMA=1, LAMBDA = 1, initNClusters = 9)
fit1$Iterates[[i]] #is a list of length two, which denotes the ith sample in MCMC output.
fit1$Iterates[[i]][[1]] ##denotes the clustering configuration z in ith iteration.
fit1$Iterates[[i]][[2]] ##denotes the Q matrix in ith iteration.
## estimated configuration using Dahl's method, choosing first 50 iterations in MCMC as burn-in
result1 = getDahl(fit1, burn = 50)
result1[[1]] ##denotes the estimated clustering configuration.
result1[[2]] ##denotes the estimated Q matrix.
## dolphin data example
## loading the data
load("yourpathway/dolphin_data.rda")  #you can find the dolphin_data.rda under the data folder.
setwd("C:/Users/ericg/Downloads")
devtools::install_github("sakulcodes/MFMSBM")
library(MFMSBM)
## generate the data
set.seed(33)
n = 100 ## number of observations
kk = 3 ## number of clusters
Z <- c(sample(1:kk, size = kk, replace = FALSE),
sample(1:kk, size = n-kk, replace = TRUE,prob = c(1,1,1))) # clustering configuration
Z = Z[order(Z)]
theta <- matrix(0.1,kk,kk) ## off-diagonal value for Q matrix
diag(theta) = 0.6 ## diagonal value for Q matrix
A = matrix(0,n,n) ##the adjacency matrix
AAA = matrix(0,n,n) ##the upper traiangle for the adjacency matrix
for (i in 1:n){
for (j in i:n){
A[i,j] = rbinom(1,1,prob=theta[Z[i],Z[j]])
A[j,i] = A[i,j]
AAA[i,j] = A[i,j]
}
}
diag(AAA) = 0 ## making it without-selfloop network
diag(A) = 0 ## making it without-selfloop networkk
## taking the data into the MFM-SBM algorithm
set.seed(1)
fit1 = CDMFM_new(data = A, data1 = AAA, niterations = 100, beta.a = 1, beta.b = 1, GAMMA=1, LAMBDA = 1, initNClusters = 9)
fit1$Iterates[[i]] #is a list of length two, which denotes the ith sample in MCMC output.
fit1$Iterates[[i]][[1]] ##denotes the clustering configuration z in ith iteration.
fit1$Iterates[[i]][[2]] ##denotes the Q matrix in ith iteration.
## estimated configuration using Dahl's method, choosing first 50 iterations in MCMC as burn-in
result1 = getDahl(fit1, burn = 50)
result1[[1]] ##denotes the estimated clustering configuration.
result1[[2]] ##denotes the estimated Q matrix.
## dolphin data example
## loading the data
load("yourpathway/dolphin_data.rda")  #you can find the dolphin_data.rda under the data folder.
devtools::install_github("sakulcodes/MFMSBM")
library(MFMSBM)
## generate the data
set.seed(33)
n = 100 ## number of observations
kk = 3 ## number of clusters
Z <- c(sample(1:kk, size = kk, replace = FALSE),
sample(1:kk, size = n-kk, replace = TRUE,prob = c(1,1,1))) # clustering configuration
Z = Z[order(Z)]
theta <- matrix(0.1,kk,kk) ## off-diagonal value for Q matrix
diag(theta) = 0.6 ## diagonal value for Q matrix
A = matrix(0,n,n) ##the adjacency matrix
AAA = matrix(0,n,n) ##the upper traiangle for the adjacency matrix
for (i in 1:n){
for (j in i:n){
A[i,j] = rbinom(1,1,prob=theta[Z[i],Z[j]])
A[j,i] = A[i,j]
AAA[i,j] = A[i,j]
}
}
diag(AAA) = 0 ## making it without-selfloop network
diag(A) = 0 ## making it without-selfloop networkk
## taking the data into the MFM-SBM algorithm
set.seed(1)
fit1 = CDMFM_new(data = A, data1 = AAA, niterations = 100, beta.a = 1, beta.b = 1, GAMMA=1, LAMBDA = 1, initNClusters = 9)
fit1$Iterates[[i]] #is a list of length two, which denotes the ith sample in MCMC output.
fit1$Iterates[[i]][[1]] ##denotes the clustering configuration z in ith iteration.
fit1$Iterates[[i]][[2]] ##denotes the Q matrix in ith iteration.
## estimated configuration using Dahl's method, choosing first 50 iterations in MCMC as burn-in
result1 = getDahl(fit1, burn = 50)
result1[[1]] ##denotes the estimated clustering configuration.
result1[[2]] ##denotes the estimated Q matrix.
## dolphin data example
## loading the data
load("dolphin_data.rda")  #you can find the dolphin_data.rda under the data folder.
set.seed(3);
fit_dol = CDMFM_new(data = A, data1 = AAA, niterations = 300, beta.a = 2, beta.b = 2, GAMMA=1,LAMBDA = 1,initNClusters=ceiling(runif(1,1,10)))
## estimated clustering configuration using Dahl's method, choosing first 100 iterations in MCMC as burn-in
result_dol = getDahl(fit_dol, burn = 100)
result_do1
result_dol
library(GPRrdd)
library(GPRdd)
library(GPRrdd)
?create_plot
library(GPRdd)
library(GPRrdd)
set.seed(100)
sc = seq(0, 1, length.out = 50)
st = seq(1, 2, length.out = 50)
yc = 1 * sc + rnorm(50, 0, 0.25)
yt = 2 + 1*st + rnorm(50, 0, 0.25)
x = c(sc, st)
x = as.matrix(x)
y = c(yc, yt)
gp_prior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7)
gp_posterior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7))
gp_posterior(Xc = sc, Xt = st, Yc = yc, Yt = yt, sigma_hat = 1.2, l = 0.7)
create_plot(X=x, Y=y, b = 1, col_num = 1, sigma_gp = 2, sigma_hat = 1.2, choice = 1, l = 0.7)
